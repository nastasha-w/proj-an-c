Nastasha Wijers, 2018-06-04. 
Updates:
2018-07-20
2018-07-23

Instructions and options for the python wrapper:

!! The version included here is in developement. Some of the function and 
options included here are untested, or do not work at all. Check these 
instructions, and/or the comments and docstrings (the part between the two
''' occurences) for these functions before using them.

Note that this does not only do 2d projections. Calculating e.g. particle 
luminosities and ion numbers is also easy with functions in this code. There
is a list of functions at the end of this document, but probaly the most 
interesting functions are the particle luminosity and ion/element number 
density calculations, as well as some smaller 'utility functions' to calculate
things like solid angles, angular diameters ditances, and luminosity-to-
surface-brightness and ion number-to-column-density conversion factors. (These
are probably also somewhere is astropy.) There are also functions to 
z-interpolate Serena Bertone's ion balance and line emission tables, and to get
the table values for arrays of particle temperatures and densities. If you want
to project something you already caluclated, the 'project' function is 
basically just a python wrapper for the HsmlAndProject c function. There are
also function which compute per-particle cooling rates and cooling times, which
can work with simulation data or by-hand input. Note that these cooling 
functions may not be entirely accurate. (Comparison to the paper presenting 
them shows cooling time contours may be off by ~0.1-0.2 dex, with similar
differences being difficult to detect in other plot comparisons.)

Some of the classes may also be handy in other uses (especially Simfile, though
all it adds to the read_eagle(_files) classes is flexibility for use with
different simulations), but they might not be very user-friendly (Vardict), and
will be overcomplicated for many applciations (Vardict, Sel).

The simfileclone.py files contains some classes and examples useful for testing
calculations and projections.



-------------------------------------------------------------------------------
Setting up: make_maps_opts_locs.py
-------------------------------------------------------------------------------
This file tells make_maps_v3_master.py (any many of my other scripts) where to
find things. This is the only python script you should have to modify when 
setting everything up on a new system. For a quick start, the locations should
be sufficient.


locations:
----------
file_type:         default file type for read_eagle. I use snapshots ('snap') 
                   here. In the readfile class, this is just a default, but 
                   functions calling readfile only use this default option.
simdir_eagle:      where to find the EAGLE outputs. Filling in the box 
                   indicator (e.g. 'L0100N1504') and adding the variation name 
                   (e.g. '/REFERENCE/') should give the directory containing 
                   the 'data' directory that read_eagle_files will search. 
                   (see make_maps_v3_master.py, class Simfile, __init__, 
                   if simulation == 'eagle' for how this variable is used) 
simdir_bahamas:    where to find the BAHAMAS outputs. Filling in the box 
                   indicator (e.g. 'L400N1024') should give the directory 
                   that read_bahamas_files will search. 
                   (see make_maps_v3_master.py, class Simfile, __init__, 
                   if simulation == 'bahamas' for how this variable is used) 
simdir_eagle_noneq:stub for where to find Ben Oppenheimer's non-equilibrium 
                   runs. Use of this variable is still in development

ndir:              where to put the output files generated by 
                   make_maps_v3_master. default: same folder as 
                   make_maps_v3_master
mdir, pdir:        ouput directories used by scripts not included here 
                   (images and processed projections)

dir_emtab:         when filling in the redshift, this should give a directory
                   of Serena Bertone's emission tables by element
dir_iontab:        when filling in <ion>.hdf5, this should give Serena 
                   Bertone's ion balance tables for that ion
dir_coolingtab:    directory containing the z_*.hdf5 cooling table files
                   presented in Wiersma, Schaye, & Smith (2009) (downloadable)
c_interpfile:      the interpolation executable create by running make in 
                   the interp2d folder 
hsml_dir:          the directory containing the HsmlAndProject executables


kernel_list:       which kernels you can choose from (should match naming of
                   the HsmlAndProject executables)
desngb:            number of neighbours for smoothing length calculation in 
                   HsmlAndProject. This is not required when working with gas.

The simdir_... variables only matter if you use that simulation. Other than 
that, you should be able to run this using the default settings (as included 
here) for everything but the simulation location and the location of the ion 
balance tables (if you want column densities) or emission tables (if you want 
surface brightnesses). 

The defaults are for the directory system as used in this package, or the 
Leiden system for the ion/emission tables and the simulations, and should work 
there.

For a quick start, you can ignore the table data part of this section.

data for Serena Bertone's ion balance and line emission tables:
---------------------------------------------------------------
zopts:           redshifts for which Serena Bertone's tables were made. strings
                 match file names
elements:        names of elements tracked in the eagle simulations
ions:            list of ions for which ion balance tables are available
zpoints:         float version of zopts
solar_abunds_ea: solar abundances used in the eagle simulations (used to scale 
                 fixed particle solar abundances to mass fractions)
solar_abunds_sb: solar abundances used in Serena Bertone's table generation 
                 (number fraction)
solar_abunds:    solar abundances used in Serena Bertone's tables, in mass 
                 fraction (used to rescale emission at solar abundance to 
                 gas abundance)
elements_ion:    element each ion is an ion of (used to look up e.g. ion atomic
                 masses), or element producing that line
line_nos_ion:    index in emission table belonging to the line
line_eng_ion:    energy of the line (cgs)
snapzstr:        unused

There is room to add plenty of other lines to line_nos_ion, line_eng_ion, and
elements_ion. In this case, just make sure your line names are unique. Overlap
with ion names should not be a problem.

data for Rob Wiersma's cooling tables:
--------------------------------------
eltdct_to_ct:    converts lowercase/uppercase and spelling of sulfur/sulphur
                 from standard/Serena Bertone version to names in Rob Wiersma's
                 tables
eltdct_from_ct:  reverse translation, but keeps uppercase names



-------------------------------------------------------------------------------
Quick start: run_projection.py
-------------------------------------------------------------------------------
run_projection.py sets a few variables in a nice overview, prints some of them,
and calls make_map in make_maps_v3_master.
just run as
> setenv OMP_NUM_THREADS 8 
(other system users will thank you)
> python2.7 run_projection.py > logfile_new.txt
the > logfile_new.txt is not required, but quite a lot is printed, so it can be
useful. 
The files I got from running this are called logfile.txt and massprojection.npz 
(renamed from the default). 

This projects the gas mass of the whole L0025N0376 EAGLE REFERENCE at z=0.0 box
onto a 256x256 grid. 

If you are using the OpenMP option, don't forget to set the OMP_NUM_THREADS 
environment variable! Before you run the script, in your shell, type
> setenv OMP_NUM_THREADS <number> 
or 
> OMP_NUM_THREADS=<number>
If you don't, some systems (all that I know of) will let the program take up 
every CPU it can, which may really annoy other people using that computer.

Output is named automatically; the names are included in the printed output. It 
is currently stored as .npz files (numpy binary archives), which have a maximum 
size of 4GB. The name of the output array in the archive in 'arr_0';
retrieve in python as
output = np.load('massprojection.npz')['arr_0']

documentation of the make_map function in make_maps_v3_master called in this 
script follows. It is an expanded version of the function's docstring


input simulation
------------------
simnum:    only L####N####; string. e.g. L0050L0752 for the mid-resolution 
           50 Mpc box (EAGLE). Matches the directory tree for the hdf5 outputs
var:       'REFERENCE', 'RECALIBRATED', etc.; string
           default ('auto') means 'REFERENCE' for all but L0025N0752 (RECAL)
           name for the set of parameters EAGLE was run with. Matches the 
           directory tree for the hdf5 outputs
snapnum:   number of the snapshot; integer. (Current implementation only does
           snapshot outputs)
simulation:which simulation to use; 'eagle' or 'bahamas'
           default 'eagle'

what to project (particle selection)
-----------------
centre:    centre of the box to select particles in; list of 3 floats
L_x (y,z): total length of the region to project in the x, (y,z) direction; 
           float
LsinMpc:   are L_x,y,z and centre given in Mpc (True) or Mpc/h (False); 
           boolean or None
           if None: True for EAGLE, False for BAHAMAS
           default None
log:       return log of projected values; boolean
           default True is strongly recommended to prevent float32 overflow
           in the output
theta, psi, phi: angles to rotate image before plotting; float
           UNIMPLEMENTED after modifications to Marijke's make_maps
axis:      axis to project along; string
           options: 'x', 'y', 'z'
velcut:    select particles along the projection axis by velocity in stead of 
           position; boolean
           uses hubble flow equivalent of region given in position space to 
           define the selected region in velocity space
           default: False
npix_x,    number of pixels to use in the prjection in the x and y 
npix_y:    directions (int). Naming only uses the number of x pixels, and 
           the minimum smoothing length uses the pixel diagonal, so using 
           non-square pixels will not improve the resolution along one 
           direction by much
select:    does not currently do anything

The chosen region is assumed to be a continuous block that does not overlap 
the boundaries of the box. Use emission_calc(_perfile) in make_maps for 
regions overlapping boundaries, or split such regions up before mapping.

quantities to project
-----------------
two quantities can be projected: W and Q
W is projected directly: the output map is the sum of the particle 
contributions in each grid cell, divided by the surface area of the grid cell
for Q, a W-weighted average is calculated in each cell
parameters describing what quantities to calculate have W/Q versions, that
do the same thing, but for the different quantities. For the Q options,
None can be used for all if no weighted average is desired
    
ptypeW/    the category of quantity to project (str)
ptypeQ:    options are 'basic', 'emission', 'coldens', and for ptypeQ, None
           'basic' means a quantity stored in the EAGLE output
           default: None for ptypeQ
ionW/      required for ptype options 'emission' and 'coldens'
ionQ:      for ptype option 'basic', option is ignored
           ion/element for which to calculated the column density 
           (ptype 'coldens'). Elements use lower case letters ('oxygen'), ions
           use lower case chemical abbreviations and arabic numerals ('o7').
           or ion/line of which to calculated the emission 
           (ptype 'emission') see make_maps_opts_locs.py for the emission lines
           available, or find your own in Serena Bertone's tables.           
quantityW/ required for ptype option 'basic'
quantityQ: for ptype options 'emission' and 'coldens', option is ignored
           the quantity from the EAGLE output to project (string)
           should be the path in the hdf5 file starting after PartType#/
           see the simulation hdf5 files for the options
parttype:  required for ptype option 'basic'
           for ptype options 'emission' and 'coldens', option is ignored
           the particle type for which to project (string!)
           0 (default): gas
           1: DM
           4: Stars
           5: BHs                     
    
technical choices
-------------------
abundsW/   type of SPH abundances; string, float, or tuple(option,option)
abundsQ:   if one option is given,
           smoothed/particle abundances are used for both nH and element                
           abundances 
           float is fixed element abundance in eagle solar units 
           (see make_maps_opts_locs); for emission and coldens,
           the primordial hydrogen abundance is then used to calculate
           lognH
           if tuple option is given,
           then the first element (index 0) is for the element abundance, 
           and the second for hydrogen (lognH calculation for emission and 
           absorption); float option here is in (absolute)  mass fraction
           'auto' is smoothed for ptype 'emission', particle for 'coldens',
           and same as the one-option setting for hydrogen
           options are 'Sm', 'Pt', 'auto', float, or a tuple of these
           Note that just because all these options are available, does not
           mean they all make sense.
kernel:    smoothing kernel to use in projections; string
           options: 'C2', 'gadget'
           default: 'C2'
           see HsmlAndProject Makefile or kernel_v3_omp.c for other options
periodic:  use periodic boundary conditions (not along projection axis); 
           boolean
           Should be true if you are projecting the whole box (in the plane 
           perpendicular to the projection axis) and false if you are 
           projecting a small part of it. Periodic only in one direction is not
           an option.
excludeSFRW/ how to handle particle on the equation of state (ISM); string/bool  
excludeSFRQ: options are 
           True   -> exclude EOS particles
           False  -> include EOS particles at face temperature
           'T4'   -> include EOS particles at T = 1e4 K
           'only' -> include only EOS particles
           'from' -> use only EOS particles or calculate halpha
                     emission from the star formation rate (ptype 
                     'emission', currently only for ion 'halpha')
           since Q and W must use the same particles, only False and T4
           or from and only can be combined with each other
misc:      intended for one-off uses without messing with the rest
           dict or None (default)
           used in nameoutput with simple key-value naming
           no checks in inputcheck: typically single-function modifications
           checks are done there
ompproj:   use the OpenMP implementation of the C projection routine (bool)

When projecting gas, the stored smoothing lengths are used. For dark matter, 
the function will try to calculate the smoothing lengths, but this will proably 
fail due to integer overflow in the 100 Mpc box. Stars and black holes get their
smoothing length set to the minimum value, which is probably not what you want 
for science projections. 

output
--------
always:    2D array of projected emission
optional:  if saveres (bool), .npz file containing the 2D array (naming is 
           automatic)


               
modify make_maps_opts_locs for locations of interpolation files (c), 
projection routine (c), ion balance and emission tables (hdf5) and write 
locations
  







-------------------------------------------------------------------------------
Overview of python scripts in this folder and their dependencies
-------------------------------------------------------------------------------
- ion_header.py: lookup  tables for atomic weights by species, and what appears
  to be a list of CHIMES abundance table indices by species (NOT CHECKED!)
  dependencies:
  o eagle_constants_and_units
- eagle_constants_and_units.py: all in the name. In the python wrapper, I use 
  cosmological parameters and unit conversions from the simulation outputs, via
  read_eagle and its wrappers. I do use CGS physical constants, including atomic 
  weights, from this file.
  dependencies:
  o numpy (unused)
- make_maps_opts_locs: locations of needed input and output, data for emission
  and absorption tables, and some defaults
  dependencies:
  o eagle_constants_and_units
  o string
  o ion_header

- make_maps_v3_master dependencies:
  o numpy
  o ctypes
  o string
  o read_eagle_files if using EAGLE output (conditional import)
  o read_bahamas_files if using BAHAMAS output (conditional import)
  o h5py
  o ion_header
  o eagle_constants_and_units
  

- simfileclone.py: defines a class Simfileclone, which has the same read_array
  function and attributes as Simfile, and can be used with Vardict in the same
  way. Useful for testing purposes. Also contains some example instances ready
  for use with the cooling table calculations.
  dependencies:
  o numpy
  o eagle_constants_and_units
  o make_maps_v3_master: for Hubble(z) and the Sel class

-------------------------------------------------------------------------------
Notes for modifications
-------------------------------------------------------------------------------

I have tried to make the functions modular, and agnostic to where they are 
used. This is why I use the Vardict class to manage read-in and deletion of 
variables. Try to do the same to make new function easier to integrate into 
projections or combine with other calculations.

If a new function introduces dependencies that are not available in most python
installations (e.g. scipy is not a problem) and are only used in specific cases, 
please load them only if the function is called. For documentation, add the 
dependency and when it arises to the dependencies section above.  




Things I might implement later:
- selection of SPH particles for projection by something other than position 
  (e.g. only particles at low overdensity; stubs present)
- projecting the C-EAGLE boxes
- simplifying or further automating the process of determining which particle
  variables are still needed (stubs present)


------------------------------------------------------------------------------
Overview of functions and classes in make_maps_v3_master.py
------------------------------------------------------------------------------
The comments and docstrings in these functions generally provide information 
as well, and may be more up-to-date than this overview. To find in the file, 
just search for 'class <class name>' or 'def <function name>'. (Line numbers
are easy to change and easy to forget to update.)
See the quick start guide for an overview of many of the variables controlling
make_map and the functions it calls.


classes:
--------
- Simfile:
  wrapper for the file objects in the different read_eagle variants. Once set
  up, functions can call an object of this class without having to know which 
  simulation it came from. The only exception is that whether or not the 
  outputs include hash tables (Simfile.region_supported) determines the best 
  way to select particles from a spatial region.
  methods:
  o __init__ retrieves cosmological parameters,
    and sets the array reading method and region_supported based on which 
    simulation is to be used
  o readarray retrieves an array from the simulation. The name is the full 
    internal hdf5 name, e.g. 'PartType1/Mass' or 
    'PartType0/SmoothedelementAbundance/Helium'

- Sel:
  A 'selector': boolean array or slice(None,None,None). Defined to allow 
  particle selections to be used and updated independent of whether a previous 
  selection was defined. This allows e.g. the selection of only particles with 
  metallicity > 0, without having to know whether a spatial selection was done 
  using hash tables or explicitly using a previous selection
  properties:
  o val: value, boolean array or slice(None,None,None). array[Sel.val] always
    should be a (sub)array of array.  
  o seldef: whether the Sel instance is a dummy (slice(None,None,None)) or an 
    actual selection (boolean array)
  methods:
  o __init__:
    set as an undefined selection, or with a boolean array. The array can be 
    input as a dictionary using the key 'arr' or as something specified (key)
  o __str__: 
    prints the instance; used for bug checking
  o comb: 
    comine the Sel instance with a different instance, or specify arr, key as
    for __init__. Comination is done using element-wise and
  o refine:
    same as comb, but the Sel instance or array specified by arr has length 
    equal to the number of 'True' entries in the current selection: the new
    selection is a selection of the current one. (Allows e.g. the selection
    of metallicity > 0 particles from a set selected by position without 
    getting every particle's metallicity.)
  o reset:
    set Sel.seldef = False, Sel.val = slice(Noen,None,None). Used for debugging

- Vardict:
  'Variable dictionary'. Its main feature is a dictionary which allows passing 
  of large arrays to functions without making copies, as well as a read 
  function which checks if it already has a variable, and a delete function 
  which check if it will need a variable later. These allow functions using 
  Vardict to be more agnostic about where they are called. Uses Sel and Simfile

  properties:
  o simfile: Simfile instance from which Vardict will get everything
  o parttype: particle type to be read in (one instance only holds one set of
    particles). 0=gas, 1=DM, 4=Stars, 5=BHs
  o wishlist: which variables to keep of you get them
  o particle: dictionary of particle properties
  o box:      dictionary of box (regio to project) properties 
  o CGSconv:  dictionary with keys matching those in particle, with the factors 
              to convert its arrays to CGS
  o readsel:  selection to apply to all particle quantities after reading them 
              in (Sel instance)
  Particle properties that correspond directly to an hdf5 name (after 
  PartType#/, e.g. 'Temperature') are stored under those names. For other 
  properties, the names are as follows:
  logT        for log10 Temperature [K]
  lognH       for log10 hydrogen number density [cm^-3], proper volume density
  propvol     for volume [cm^-3], proper
  luminosity  for emission line luminosity; conversion to cgs stored in Vardict
  coldens     for column density; conversion to cgs stored in Vardict
  eos         for particles on the equation of state (boolean)
  note that these names do not always mean exactly the same thing. lognH can 
  take different value depending on whether the smoothed, particle, or 
  primordial hydrogen mass fraciton was used, and logT and Temperature depend
  on how the star-forming gas is handled. coldens and luminosity obviously 
  depend on which line, ion, or element is being investigated.


  methods:
  o __init__: sets up vardict
  o delif:  
    deletes a variable if is is no longer needed (not in the wishlist), or 
    forced (last=True)
  o isstored_box:
    returns True/False: does a box variable already exist  
  o isstored_part:
    returns True/False: does a particle variable already exist 
  o readif:  
    read in a particle property from the hdf5 files if it is not already stored
    note the remarks above on different definitions; in some cases, explicitly 
    deleting and reloading something may be necessary.
  o add_part:
    add a particle to the dictionary by hand. just Vardict.particle[name] = var
    with an overwrite warning
  o overwrite_part:
    Vardict.particle[name] = var, without the warning 
  o add_box and overwrite_box:
    same for box variables
  o getlognH, getpropvol, getlogT: 
    calculate lognH, propvol, or logT, add to particle dictionary
    kwarg 'logT' means 'set SF particles to 10^4 K?' (bool)

- Readfileclone: (no longer updated)
  clone of Simfile (earlier version was called Readfile), used for debugging
  lets you set up a simulation-like box, but with some convenient particle 
  positions or properties, so you know what the result of a calculation should 
  be. A more advanced version (Simfileclone) is available in simfileclone.py

- DocumentedFunction:
  function you can call as usual, but has some extra information. Stub for more
  sophisticated determination of which particle properties can be deleted 
  without requiring recalculation


functions:
----------
Called functions do not include what a called function calls

COSMOLOGY AND TRIGONOMETRY
- comoving_distance_cm(z,simfile=None):
  returns the comoving distance to a given redshift z using the cosmology of
  a simulation output (simfile) or EAGLE (from eagle_constants_and_units, 
  default)
  calls: nothing

- ang_diam_distance_cm(z,simfile=None):
  returns the angular diameter distance to a given redshift using the cosmology of
  a simulation output (simfile) or EAGLE (from eagle_constants_and_units, 
  default)
  calls: 
  o comoving_distance_cm(z,simfile=None)

- lum_distance_cm(z,simfile=None):
  returns the luminosity distance to a given redshift using the cosmology of
  a simulation output (simfile) or EAGLE (from eagle_constants_and_units, 
  default)
  calls: 
  o comoving_distance_cm(z,simfile=None)
   
- Hubble(z,simfile=None):
  returns the hubble parameter (cgs) for a given redshift using the cosmology of
  a simulation output (simfile) or EAGLE (from eagle_constants_and_units, 
  default)
  calls: nothing

- solidangle(alpha,beta):
  returns the solid angle subtended by a rectangle with half sides/distance alpha 
  and beta (more detailed desciption in comments). Uses a Taylor approximation for
  small angles, where the trigonometric functions return zero
  calls: nothing

LUMINOSITY AND ION BALANCES
- findemtables(element,zcalc):
  retrieves Serena Bertone's emission tables for a given element, and linearly
  interpolates in redshift to redshift zcalc
  returns emission table, temperatures [log10 K] the tables was calculated for,
  number densities [log10 cm^-3] the tables were calculated for

- find_emdenssq(z,elt,lognH,logT,lineind):
  given particles with hydrogen number densities lognH [log10 cm^-3] and 
  temperatures logT [log10 K] at redshift z, returns the 
  emission/hydrogen number density^2/volume [log10 cgs] of the line at table 
  index lineind of element elt
  calls:
  o findemtables(element,zcalc)
  o interp2d.so

- findiontables(ion,z):
  retrieves Serena Bertone's ion fraction tables for a given element, and 
  linearly interpolates in redshift to redshift z
  returns ion balance table, temperatures [log10 K] the tables was calculated 
  for, number densities [log10 cm^-3] the tables were calculated for

- find_ionbal(z,ion,lognH,logT):
  given particles with hydrogen number densities lognH [log10 cm^-3] and 
  temperatures logT [log10 K] at redshift z, returns the 
  ion fraction of the line ion
  calls:
  o findiontables(ion,z)
  o interp2d.so

- getcoolingtable(tablefile, per_elt = True):
  given an open hdf5 file <tablefile>, reads in the quantities needed for 
  cooling rate and/or time calculations to a dictionary. 
  per_elt=True:  read in the tables for each element
          False: read in the tables for total metals

- findcoolingtables(z, method = 'per_element'):
  read in cooling tabbles for redshift <z>, and interpolate linearly bewteen
  redshifts if necessary. returns a dictionary with the same keys as 
  getcoolingtable
  calls:
  o getcoolingtables

- find_coolingrates(z, dct, method = 'per_element', **kwargs):
  !! might be slightly wrong
  finds Lambda/nH^2 given redshift z for the radiation field, particle 
  properties in a dictionary of arrays or from a simulation via a Vardict
  instance (dct). kwargs indicate the details of which abundances to use,
  how to handle SF gas, etc. in the Vardict case
  calls:
  o findcoolingtables
  o vardict methods if Vardict is used
  o 2d and 3d interpolation c functions

- find_coolingtimes(z,dct, method = 'per_element', **kwargs): 
  !! might be slightly wrong
  returns cooling times for each particle, same arguments as find_coolingrates
  calls:
  o find_coolingrates
  o vardict methods if Vardict is used
  o 3d interpolation c function
  o findcoolingtables

- getBenOpp1chemabundtables(vardict,excludeSFR,eltab,hab,ion,last=True,
  updatesel=True,misc=None):
  read in the chemical abundances from Ben Oppenheimer's non-equilibirum runs,
  convert from native units to mass fractions
  calls:
  o vardict methods

- luminosity_calc(vardict,excludeSFR,eltab,hab,ion,last=True,updatesel=True):
  returns an array of partical lumniosities, and the value to multiply these by
  to convert these to cgs
  calls:
  o vardict methods
  o find_emdenssq

- lumninosty_to_Sb(vardict,Ls,Axis1,Axis2,Axis3,npix_x,npix_y,ion):
  returns the value needed to convert a projected total luminosity map to a 
  surface brightness map. Uses a comoving distance of at least half the longest 
  projected box dimension. (At these relatively small distances, it should not 
  matter much which is used anyway.) 
  calls:
  o solid_angle
  o comoving_distance_cm

- Nion_calc(vardict,excludeSFR,eltab,hab,ion,last=True,updatesel=True,
  misc=None):
  retrieves the number of ion is each SPH particle
  returns this number and the multiplication factor needed to convert this to 
  the CGS number of ions (called numdens, but it is not a density)
  calls:
  o vardict methods
  o find_ionbal(z,ion,lognH,logT)

- Nelt_calc(vardict,excludeSFR,eltab,ion,last=True,updatesel=True)::
  same as Nion_calc, but gets the number for an nuclei of a given element
  calls:
  o vardict methods

- Nion_to_coldens(vardict,Ls,Axis1,Axis2,Axis3,npix_x,npix_y):
  returns the factor needed to convert a number of ions/nuclei per pixel map
  to a column density map
  calls:
  o retrieves a vardict property (expansion factor a)


SPH PARTICLE SELECTION
- translate(old_dct, old_nm, centre, boxsize, periodic):
  translates dictionary element old_nm from dictionary old_dct (assumed to be
  3d coordinates) to centre at zero (non-periodic) or half the box size 
  (periodic). This is because HsmlAndProject expects this coordinate range for
  a periodic box. The coordinates are assumed to be periodic with the box size
  as the period in both cases.
  calls: nothing

- partselect_pos(simfile, centre, Ls, Axis1, Axis2, Axis3, parttype='0'):
  returns a region ([xmin, xmax, ymin, ymax, zmin, zmax], EAGLE units)
  to use with the hash tables to read in only a subset of SPH particles.
  calls:
  o simfile methods

- partselect_vel_region(simfile, centre, Ls, Axis1, Axis2, Axis3, 
  parttype = '0'):
  obsolete

- ppv_selselect_coordsgen(centre, Ls, Axis1, Axis2, Axis3, periodic, vardict,
  parttype = '0'):
  selects particles in position-poisition-velocity space (velocity along axis3)
  where the centre and length along the projection axis are converted to their
  hubble-flow equivalents
  calls:
  o translate
  o vardict methods
  o sel methods

- ppp_selselect_coordsadd(centre, Ls, periodic, vardict, parttype = '0',
  keepcoords=True):
  selects particles in position space
  keepcoords: store coordinates, or delete them (recalculate before projecting)
  o vardict methods
  o sel methods
  

make_map AND ITS DEDICATED SUPPORT FUNCTIONS
- nameoutput(ptypeW,simnum,snapnum,version,kernel,npix_x,L_x,L_y,L_z,centre,
  BoxSize,hconst,excludeSFRW,excludeSFRQ,velcut,axis,var,abundsW,ionW,parttype,
  ptypeQ,abundsQ,ionQ,quantityW,quantityQ,simulation,LsinMpc,misc):
  returns the output name for the projected quantity if quantityW is None, 
  otherwise the output name for the averaged quantity
  called after inputcheck

- inputcheck(simnum, snapnum, centre, L_x, L_y, L_z, npix_x, npix_y, \
         ptypeW,\
         ionW, abundsW, quantityW,\
         ionQ, abundsQ, quantityQ, ptypeQ,\
         excludeSFRW, excludeSFRQ, parttype,\
         theta, phi, psi, \
         var, axis, log, velcut,\
         periodic, kernel, saveres,\
         simulation, LsinMpc,\
         select, misc, ompproj):
  checks the input to make_map and sets default options. returns modified 
  parameters. The check is not exhaustive, but is meant to catch at least 
  some wrong input parameters of combinations of input parameters before
  you waste computer time on them.

- get_eltab_names(abunds,iselt,ion):
  returns eltab, hab (see useful variables)
  inputs: abundances - tuple of length 2 (element, hydrogen), 
          each can be float (fixed mass fraction), 'Sm' (smoothed abundance)
          or 'Pt' (particle abundance)
  calls: nothing

- readbasic(vardict,quantity,excludeSFR,last = True,**kwargs):
  reads in properties from a simulation, or lognH, logT, or the proper volume
  propvol. kwargs are for e.g. eltab or T4EOS variables used only for specific 
  quantities
 
- project(NumPart,Ls,Axis1,Axis2,Axis3,box3,periodic,npix_x,npix_y,kernel,dct,
  tree,ompproj=True):
  wrapper for the HsmlAndProject... functions. periodic, kernel, tree, 
  and ompproj determine which is called. 
  o kernel matches the kernel names in the executable, 
  o tree detrmines whether the smoothing lengths are checked and possibly 
    calculated, 
  o periodic determines whether periodic boundary conditions are applied
  o ompproj determines whether the parallel verions of the projection code is 
    used
  o dct is a dictionary with the entries 
    + 'coords' (coordinates, same units as Ls, must be between 0 and Ls[i] 
      along each dimension if periodic)
    + 'lsmooth' (smoothing length, same units as coordinates and Ls)
    + 'qQ' (quantity to project onto a 2d map)
    + 'qW' (quantity to get the average of weighted by qQ on the same map)
  o NumPart is the number of particles in the projection (length of the 
    particle arrays) 
  returns the 2d W and Q projections

- make_map(simnum, snapnum, centre, L_x, L_y, L_z, npix_x, npix_y, \
         ptypeW,\
         ionW = None, abundsW = 'auto', quantityW = None,\
         ionQ = None, abundsQ = 'auto', quantityQ = None, ptypeQ = None,\
         excludeSFRW = False, excludeSFRQ = False, parttype = '0',\
         theta=0.0, phi=0.0, psi=0.0, \
         var='auto', axis ='z',log=True, velcut = False,\
         periodic = True, kernel = 'C2', saveres = False,\
         simulation = 'eagle', LsinMpc = None,\
         select = None, misc = None, ompproj = False):
 see overview in the quick start section
 

OPTIMISATION
for determining which quantities will be useful later on -> don't delete
- getwishlist(funcname,**kwargs): untested, unused
- getsubswishlist(subs, settings): untested, unused
- removesettingsdiffs(overlap,settings1,settings2): untested, unused
- combwishlist(neededsubssettingsfirst,neededsubssettingssecond): untested, 
                                                                  unused

OTHER:
- get_EA_FOF_MRCOP(simnum,snapnum,var = None,mdef='200c', outdct = None):
  retrieves FOF data from the subfind outputs, puts it into a dictionary
  which it returns 
  calls:
  o simfile methods


variables that are useful to know:
----------------------------------

axis1, axis2, axis3: set based on the projection axis, used as position 
                     indices.
                     e.g. if projecting along the z-axis, axis1=0, axis2=1, 
                     axis3=2. Using these variables as indices avoids checking 
                     the projection axis any time you need retrieve positions

eltab, hab:          the element and hydrogen abundances in use (may be the 
                     same, if we want e.g. halpha emission or total hydrogen
                     column densities)   
                     float values if a fixed mass fraction, otherwise 
                     'ElementAbundance/<Element>' or 
                     'SmoothedElementAbundance/<Element>'.
                     float or string still requires checking, but otherwise, 
                     this prevents constantly checking which abundance is in 
                     use

last:                in conditional SPH particle array deletion 
                     (Vardict.delif), setting last=True means 'just delete it'.
                     intended to indicate that this is definitely the last use
                     of that particle property 

updatesel:           allow a function to update the selection of SPH particles
                     in use. If True, for example, the column density 
                     calculation function will just 'throw out' any particles 
                     that do not contain any of the element of which the ion
                     is a species. 

centre, Ls:          centre and side lengths of the region to be projected

W,Q:                 generally refer to the quantity of which we want some sort
                     of surface density (W) and and average weighted by W (Q)
                     some properties are calculated for both or either, and get
                     W or Q in their names    
